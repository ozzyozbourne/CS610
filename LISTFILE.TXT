    1 
    2 /*
    3 Header for tinydog.pgm - the file used in this example
    4 P2
    5 # Created by GIMP version 2.10.34 PNM plug-in
    6 25 19
    7 255
    8 */
    9 #include <stdlib.h>
   10 /* Number of lines in <image>.pgm header */
   11 #define header_lines 4;
   12 /* "Hard coding" image header values into sizing and values to be written out.
   13     Change this to match the values in your image */
   14 /* Note: Image Type P2 will be written directly in cout */
   15 #define image_columns 110
   16 #define image_rows 142
   17 #define  MaxGrayComponentValue 255;
   18 #define carriage_return '\n'
   19 
   20 /* Here's the image array you will read into */
   21 int image_in[image_rows+ 1][image_columns+ 1];
   22 /* Here's the image you will write to */
   23 int image_out[image_rows + 1][image_columns+ 1];
   24 
   25 /*here's your iterators to scan through the image*/
   26 int i, j;
   27 
   28 /* End of Global variables Shared Memory*/
   29 
   30 void read_image_header()
   31  {
   32 /* this procedure reads the four header lines and throw them away*/
   33     char buffer[header_lines+1][80]; /* buffer for storing input line */
   34     char c;
   35     int m;
   36     for (m = 1; m <= header_lines; ++m)
   37     do
   38     {
   39       cin >> c;  /* input next character */
   40     } while (c != carriage_return);
   41  }
   42 
   43 void read_image_values()
   44   {/* read image into array */
   45     for(i = 1; i <= image_rows; i++)
   46         for( j = 1; j <= image_columns; j++)
   47          cin >> image_in[i][j];
   48    }
   49 
   50 /* Your work moothing function */
   51 
   52 int smooth_pixel(int p, int q)
   53 {
   54     int smoothed_value = (
   55         image_in[p - 1][q - 1] +
   56         image_in[p - 1][q] +
   57         image_in[p - 1][q + 1] +
   58         image_in[p][q - 1] +
   59         image_in[p][q] +
   60         image_in[p][q + 1] +
   61         image_in[p + 1][q - 1] +
   62         image_in[p + 1][q] +
   63         image_in[p + 1][q + 1]
   64     ) / 9;
   65     
   66     return smoothed_value;
   67 }
   68 
   69 void write_image_to_file()
   70  {
   71     int output_row_width = 10;
   72     int OUTPUT_ROW_COUNTER = 1;
   73     cout << "P2" << ENDL;
   74     cout << image_columns << " " << image_rows << ENDL;
   75     cout << MaxGrayComponentValue << ENDL;
   76     /*this loop write to the file in a manner acceptable to cstar 10 values per Row */
   77     for(i = 1; i <= image_rows; i++)
   78     {
   79       for ( j = 1; j <= image_columns; j++)
   80       {
   81         if (OUTPUT_ROW_COUNTER == output_row_width)
   82         {
   83           cout << ENDL;
   84           OUTPUT_ROW_COUNTER = 1;
   85         }
   86         cout << image_out[i][j] << " ";
   87         OUTPUT_ROW_COUNTER = OUTPUT_ROW_COUNTER + 1;
   88       }
   89     }
   90   }
   91 main()
   92 {
   93 
   94 read_image_header();
   95 
   96 read_image_values();
   97 
   98   /*  Your work - create the logic to process the image array_in
   99      Outer for loop is row counter.*/
  100 
  101 for(i = 1; i <= image_rows; i++) {
  102        forall j = 1 to image_columns do {
  103          if ((i != 1) && (i != image_rows) && (j != 1) && (j != image_columns)){
  104                 image_out[i][j] = smooth_pixel(i, j);
  105           } else {
  106                 image_out[i][j] = image_in[i][j];
  107           }
  108        }
  109   }
  110 write_image_to_file();
  111 
  112 }
