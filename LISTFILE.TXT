    1 /*
    2 Header for tinydog.pgm - the file used in this example
    3 P2
    4 # Created by GIMP version 2.10.34 PNM plug-in
    5 25 19
    6 255
    7 */
    8 #include <stdlib.h>
    9 /* Number of lines in <image>.pgm header */
   10 #define header_lines 4;
   11 /* "Hard coding" image header values into sizing and values to be written out.
   12     Change this to match the values in your image */
   13 /* Note: Image Type P2 will be written directly in cout */
   14 #define image_columns 110
   15 #define image_rows 142
   16 #define  MaxGrayComponentValue 255;
   17 #define carriage_return '\n'
   18 
   19 /* Here's the image array you will read into */
   20 int image_in[image_rows+ 1][image_columns+ 1];
   21 /* Here's the image you will write to */
   22 int image_out[image_rows + 1][image_columns+ 1];
   23 
   24 /*here's your iterators to scan through the image*/
   25 int i, j;
   26 
   27 /* End of Global variables Shared Memory*/
   28 
   29 void read_image_header()
   30  {
   31 /* this procedure reads the four header lines and throw them away*/
   32     char buffer[header_lines+1][80]; /* buffer for storing input line */
   33     char c;
   34     int m;
   35     for (m = 1; m <= header_lines; ++m)
   36     do
   37     {
   38       cin >> c;  /* input next character */
   39     } while (c != carriage_return);
   40  }
   41 
   42 void read_image_values()
   43   {/* read image into array */
   44     for(i = 1; i <= image_rows; i++)
   45         for( j = 1; j <= image_columns; j++)
   46          cin >> image_in[i][j];
   47    }
   48 
   49 /* Your work moothing function */
   50 
   51 int smooth_pixel(int p, int q)
   52 {
   53     int smoothed_value = (
   54         image_in[p - 1][q - 1] +
   55         image_in[p - 1][q] +
   56         image_in[p - 1][q + 1] +
   57         image_in[p][q - 1] +
   58         image_in[p][q] +
   59         image_in[p][q + 1] +
   60         image_in[p + 1][q - 1] +
   61         image_in[p + 1][q] +
   62         image_in[p + 1][q + 1]
   63     ) / 9;
   64     
   65     return smoothed_value;
   66 }
   67 
   68 
   69 void write_image_to_file()
   70  {
   71     int output_row_width = 10;
   72     int OUTPUT_ROW_COUNTER = 1;
   73     cout << "P2" << ENDL;
   74     cout << image_columns << " " << image_rows << ENDL;
   75     cout << MaxGrayComponentValue << ENDL;
   76     /*this loop write to the file in a manner acceptable to cstar 10 values per Row */
   77     for(i = 1; i <= image_rows; i++)
   78     {
   79       for ( j = 1; j <= image_columns; j++)
   80       {
   81         if (OUTPUT_ROW_COUNTER == output_row_width)
   82         {
   83           cout << ENDL;
   84           OUTPUT_ROW_COUNTER = 1;
   85         }
   86         cout << image_out[i][j] << " ";
   87         OUTPUT_ROW_COUNTER = OUTPUT_ROW_COUNTER + 1;
   88       }
   89     }
   90   }
   91 main()
   92 {
   93 
   94 read_image_header();
   95 
   96 read_image_values();
   97 
   98   /*  Your work - create the logic to process the image array_in
   99      Outer for loop is row counter.*/
  100 
  101   for(i = 1; i <= image_rows; i++)
  102      {
  103        forall j = 1 to image_columns do
  104        {
  105           if( i==1 || i==image_rows || j==1 || j== image_columns)
  106             {
  107                 image_out[i][j] = image_in[i][j];
  108             }
  109               else
  110               {
  111                 image_out[i][j] = smooth_pixel(i, j);
  112               }
  113          }
  114       }
  115 write_image_to_file();
  116 
  117 }
